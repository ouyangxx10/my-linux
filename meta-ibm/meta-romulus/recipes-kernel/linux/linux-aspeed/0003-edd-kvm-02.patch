diff --git a/drivers/media/platform/Kconfig b/drivers/media/platform/Kconfig
index 0ddb819..2a47558 100644
--- a/drivers/media/platform/Kconfig
+++ b/drivers/media/platform/Kconfig
@@ -35,6 +35,7 @@ source "drivers/media/platform/omap/Kconfig"
 config VIDEO_ASPEED
 	tristate "Aspeed AST2400 and AST2500 Video Engine driver"
 	depends on VIDEO_V4L2
+	select VIDEOBUF2_DMA_CONTIG
 	help
 	  Support for the Aspeed Video Engine (VE) embedded in the Aspeed
 	  AST2400 and AST2500 SOCs. The VE can capture and compress video data
diff --git a/drivers/media/platform/aspeed-video.c b/drivers/media/platform/aspeed-video.c
index 4f55c2e..db0a6b7 100644
--- a/drivers/media/platform/aspeed-video.c
+++ b/drivers/media/platform/aspeed-video.c
@@ -27,6 +27,7 @@
 #include <media/v4l2-device.h>
 #include <media/v4l2-event.h>
 #include <media/v4l2-ioctl.h>
+#include <media/videobuf2-dma-contig.h>
 
 #define DEVICE_NAME			"aspeed-video"
 
@@ -36,19 +37,22 @@
 #define ASPEED_VIDEO_JPEG_DCT_SIZE	34
 
 #define MAX_FRAME_RATE			60
+#define MAX_HEIGHT			1200
+#define MAX_WIDTH			1920
+
 #define NUM_POLARITY_CHECKS		10
-#define INVALID_RESOLUTION_RETRIES	1
+#define INVALID_RESOLUTION_RETRIES	2
 #define INVALID_RESOLUTION_DELAY	msecs_to_jiffies(250)
 #define RESOLUTION_CHANGE_DELAY		msecs_to_jiffies(500)
 #define MODE_DETECT_TIMEOUT		msecs_to_jiffies(500)
-#define DIRECT_FETCH_THRESHOLD		0x0c0000 /* 1024 * 768, 32bpp */
+#define STOP_TIMEOUT			msecs_to_jiffies(250)
+#define DIRECT_FETCH_THRESHOLD		0x0c0000 /* 1024 * 768 */
 
-#define VE_SRC_BUFFER_SIZE		0x900000 /* 1920 * 1200, 32bpp */
-#define VE_COMP_BUFFER_SIZE		0x100000 /* 128K packet * 8 packets */
-#define VE_JPEG_BUFFER_SIZE		0x006000 /* 512 * 12 * 4 */
+#define VE_MAX_SRC_BUFFER_SIZE		0x8ca000 /* 1920 * 1200, 32bpp */
+#define VE_JPEG_HEADER_SIZE		0x006000 /* 512 * 12 * 4 */
 
 #define VE_PROTECTION_KEY		0x000
-#define  VE_PROTECTION_KEY_UNLOCK	0x1A038AA8
+#define  VE_PROTECTION_KEY_UNLOCK	0x1a038aa8
 
 #define VE_SEQ_CTRL			0x004
 #define  VE_SEQ_CTRL_TRIG_MODE_DET	BIT(0)
@@ -169,15 +173,24 @@
 enum {
 	VIDEO_MODE_DETECT_DONE,
 	VIDEO_RES_CHANGE,
-	VIDEO_FRAME_AVAILABLE,
-	VIDEO_FRAME_TRIGGERED,
+	VIDEO_STREAMING,
+	VIDEO_FRAME_INPRG,
 };
 
 struct aspeed_video_addr {
+	unsigned int size;
 	dma_addr_t dma;
 	void *virt;
 };
 
+struct aspeed_video_buffer {
+	struct vb2_v4l2_buffer vb;
+	struct list_head link;
+};
+
+#define to_aspeed_video_buffer(x) \
+	container_of((x), struct aspeed_video_buffer, vb)
+
 struct aspeed_video {
 	void __iomem *base;
 	struct clk *eclk;
@@ -185,29 +198,29 @@ struct aspeed_video {
 	struct reset_control *rst;
 
 	struct device *dev;
-	struct v4l2_ctrl_handler v4l2_ctrl;
+	struct v4l2_ctrl_handler ctrl_handler;
 	struct v4l2_device v4l2_dev;
-	struct v4l2_format v4l2_fmt;
+	struct v4l2_pix_format pix_fmt;
+	struct v4l2_bt_timings timings;
+	struct vb2_queue queue;
 	struct video_device vdev;
 	struct mutex video_lock;
 
 	atomic_t clients;
 	wait_queue_head_t wait;
+	spinlock_t lock;
 	struct delayed_work res_work;
+	struct list_head buffers;
 	unsigned long flags;
+	unsigned int sequence;
 
-	int frame_idx;
-	u32 frame_size;
-
-	dma_addr_t max;
-	dma_addr_t min;
+	unsigned int max_compressed_size;
 	struct aspeed_video_addr srcs[2];
-	struct aspeed_video_addr comp[2];
 	struct aspeed_video_addr jpeg;
 
 	bool yuv420;
-	int frame_rate;
-	int jpeg_quality;
+	unsigned int frame_rate;
+	unsigned int jpeg_quality;
 	unsigned int height;
 	unsigned int width;
 };
@@ -215,119 +228,119 @@ struct aspeed_video {
 #define to_aspeed_video(x) container_of((x), struct aspeed_video, v4l2_dev)
 
 static const u32 aspeed_video_jpeg_header[ASPEED_VIDEO_JPEG_HEADER_SIZE] = {
-	0xE0FFD8FF, 0x464A1000, 0x01004649, 0x60000101, 0x00006000, 0x0F00FEFF,
-	0x00002D05, 0x00000000, 0x00000000, 0x00DBFF00
+	0xe0ffd8ff, 0x464a1000, 0x01004649, 0x60000101, 0x00006000, 0x0f00feff,
+	0x00002d05, 0x00000000, 0x00000000, 0x00dbff00
 };
 
 static const u32 aspeed_video_jpeg_quant[ASPEED_VIDEO_JPEG_QUANT_SIZE] = {
-	0x081100C0, 0x00000000, 0x00110103, 0x03011102, 0xC4FF0111, 0x00001F00,
+	0x081100c0, 0x00000000, 0x00110103, 0x03011102, 0xc4ff0111, 0x00001f00,
 	0x01010501, 0x01010101, 0x00000000, 0x00000000, 0x04030201, 0x08070605,
-	0xFF0B0A09, 0x10B500C4, 0x03010200, 0x03040203, 0x04040505, 0x7D010000,
-	0x00030201, 0x12051104, 0x06413121, 0x07615113, 0x32147122, 0x08A19181,
-	0xC1B14223, 0xF0D15215, 0x72623324, 0x160A0982, 0x1A191817, 0x28272625,
-	0x35342A29, 0x39383736, 0x4544433A, 0x49484746, 0x5554534A, 0x59585756,
-	0x6564635A, 0x69686766, 0x7574736A, 0x79787776, 0x8584837A, 0x89888786,
-	0x9493928A, 0x98979695, 0xA3A29A99, 0xA7A6A5A4, 0xB2AAA9A8, 0xB6B5B4B3,
-	0xBAB9B8B7, 0xC5C4C3C2, 0xC9C8C7C6, 0xD4D3D2CA, 0xD8D7D6D5, 0xE2E1DAD9,
-	0xE6E5E4E3, 0xEAE9E8E7, 0xF4F3F2F1, 0xF8F7F6F5, 0xC4FFFAF9, 0x00011F00,
+	0xff0b0a09, 0x10b500c4, 0x03010200, 0x03040203, 0x04040505, 0x7d010000,
+	0x00030201, 0x12051104, 0x06413121, 0x07615113, 0x32147122, 0x08a19181,
+	0xc1b14223, 0xf0d15215, 0x72623324, 0x160a0982, 0x1a191817, 0x28272625,
+	0x35342a29, 0x39383736, 0x4544433a, 0x49484746, 0x5554534a, 0x59585756,
+	0x6564635a, 0x69686766, 0x7574736a, 0x79787776, 0x8584837a, 0x89888786,
+	0x9493928a, 0x98979695, 0xa3a29a99, 0xa7a6a5a4, 0xb2aaa9a8, 0xb6b5b4b3,
+	0xbab9b8b7, 0xc5c4c3c2, 0xc9c8c7c6, 0xd4d3d2ca, 0xd8d7d6d5, 0xe2e1dad9,
+	0xe6e5e4e3, 0xeae9e8e7, 0xf4f3f2f1, 0xf8f7f6f5, 0xc4fffaf9, 0x00011f00,
 	0x01010103, 0x01010101, 0x00000101, 0x00000000, 0x04030201, 0x08070605,
-	0xFF0B0A09, 0x11B500C4, 0x02010200, 0x04030404, 0x04040507, 0x77020100,
+	0xff0b0a09, 0x11b500c4, 0x02010200, 0x04030404, 0x04040507, 0x77020100,
 	0x03020100, 0x21050411, 0x41120631, 0x71610751, 0x81322213, 0x91421408,
-	0x09C1B1A1, 0xF0523323, 0xD1726215, 0x3424160A, 0x17F125E1, 0x261A1918,
-	0x2A292827, 0x38373635, 0x44433A39, 0x48474645, 0x54534A49, 0x58575655,
-	0x64635A59, 0x68676665, 0x74736A69, 0x78777675, 0x83827A79, 0x87868584,
-	0x928A8988, 0x96959493, 0x9A999897, 0xA5A4A3A2, 0xA9A8A7A6, 0xB4B3B2AA,
-	0xB8B7B6B5, 0xC3C2BAB9, 0xC7C6C5C4, 0xD2CAC9C8, 0xD6D5D4D3, 0xDAD9D8D7,
-	0xE5E4E3E2, 0xE9E8E7E6, 0xF4F3F2EA, 0xF8F7F6F5, 0xDAFFFAF9, 0x01030C00,
-	0x03110200, 0x003F0011
+	0x09c1b1a1, 0xf0523323, 0xd1726215, 0x3424160a, 0x17f125e1, 0x261a1918,
+	0x2a292827, 0x38373635, 0x44433a39, 0x48474645, 0x54534a49, 0x58575655,
+	0x64635a59, 0x68676665, 0x74736a69, 0x78777675, 0x83827a79, 0x87868584,
+	0x928a8988, 0x96959493, 0x9a999897, 0xa5a4a3a2, 0xa9a8a7a6, 0xb4b3b2aa,
+	0xb8b7b6b5, 0xc3c2bab9, 0xc7c6c5c4, 0xd2cac9c8, 0xd6d5d4d3, 0xdad9d8d7,
+	0xe5e4e3e2, 0xe9e8e7e6, 0xf4f3f2ea, 0xf8f7f6f5, 0xdafffaf9, 0x01030c00,
+	0x03110200, 0x003f0011
 };
 
 static const u32 aspeed_video_jpeg_dct[ASPEED_VIDEO_JPEG_NUM_QUALITIES]
 				      [ASPEED_VIDEO_JPEG_DCT_SIZE] = {
-	{ 0x0D140043, 0x0C0F110F, 0x11101114, 0x17141516, 0x1E20321E,
-	  0x3D1E1B1B, 0x32242E2B, 0x4B4C3F48, 0x44463F47, 0x61735A50,
-	  0x566C5550, 0x88644644, 0x7A766C65, 0x4D808280, 0x8C978D60,
-	  0x7E73967D, 0xDBFF7B80, 0x1F014300, 0x272D2121, 0x3030582D,
-	  0x697BB958, 0xB8B9B97B, 0xB9B8A6A6, 0xB9B9B9B9, 0xB9B9B9B9,
-	  0xB9B9B9B9, 0xB9B9B9B9, 0xB9B9B9B9, 0xB9B9B9B9, 0xB9B9B9B9,
-	  0xB9B9B9B9, 0xB9B9B9B9, 0xB9B9B9B9, 0xFFB9B9B9 },
-	{ 0x0C110043, 0x0A0D0F0D, 0x0F0E0F11, 0x14111213, 0x1A1C2B1A,
-	  0x351A1818, 0x2B1F2826, 0x4142373F, 0x3C3D373E, 0x55644E46,
-	  0x4B5F4A46, 0x77573D3C, 0x6B675F58, 0x43707170, 0x7A847B54,
-	  0x6E64836D, 0xDBFF6C70, 0x1B014300, 0x22271D1D, 0x2A2A4C27,
-	  0x5B6BA04C, 0xA0A0A06B, 0xA0A0A0A0, 0xA0A0A0A0, 0xA0A0A0A0,
-	  0xA0A0A0A0, 0xA0A0A0A0, 0xA0A0A0A0, 0xA0A0A0A0, 0xA0A0A0A0,
-	  0xA0A0A0A0, 0xA0A0A0A0, 0xA0A0A0A0, 0xFFA0A0A0 },
-	{ 0x090E0043, 0x090A0C0A, 0x0C0B0C0E, 0x110E0F10, 0x15172415,
-	  0x2C151313, 0x241A211F, 0x36372E34, 0x31322E33, 0x4653413A,
-	  0x3E4E3D3A, 0x62483231, 0x58564E49, 0x385D5E5D, 0x656D6645,
-	  0x5B536C5A, 0xDBFF595D, 0x16014300, 0x1C201818, 0x22223F20,
-	  0x4B58853F, 0x85858558, 0x85858585, 0x85858585, 0x85858585,
+	{ 0x0d140043, 0x0c0f110f, 0x11101114, 0x17141516, 0x1e20321e,
+	  0x3d1e1b1b, 0x32242e2b, 0x4b4c3f48, 0x44463f47, 0x61735a50,
+	  0x566c5550, 0x88644644, 0x7a766c65, 0x4d808280, 0x8c978d60,
+	  0x7e73967d, 0xdbff7b80, 0x1f014300, 0x272d2121, 0x3030582d,
+	  0x697bb958, 0xb8b9b97b, 0xb9b8a6a6, 0xb9b9b9b9, 0xb9b9b9b9,
+	  0xb9b9b9b9, 0xb9b9b9b9, 0xb9b9b9b9, 0xb9b9b9b9, 0xb9b9b9b9,
+	  0xb9b9b9b9, 0xb9b9b9b9, 0xb9b9b9b9, 0xffb9b9b9 },
+	{ 0x0c110043, 0x0a0d0f0d, 0x0f0e0f11, 0x14111213, 0x1a1c2b1a,
+	  0x351a1818, 0x2b1f2826, 0x4142373f, 0x3c3d373e, 0x55644e46,
+	  0x4b5f4a46, 0x77573d3c, 0x6b675f58, 0x43707170, 0x7a847b54,
+	  0x6e64836d, 0xdbff6c70, 0x1b014300, 0x22271d1d, 0x2a2a4c27,
+	  0x5b6ba04c, 0xa0a0a06b, 0xa0a0a0a0, 0xa0a0a0a0, 0xa0a0a0a0,
+	  0xa0a0a0a0, 0xa0a0a0a0, 0xa0a0a0a0, 0xa0a0a0a0, 0xa0a0a0a0,
+	  0xa0a0a0a0, 0xa0a0a0a0, 0xa0a0a0a0, 0xffa0a0a0 },
+	{ 0x090e0043, 0x090a0c0a, 0x0c0b0c0e, 0x110e0f10, 0x15172415,
+	  0x2c151313, 0x241a211f, 0x36372e34, 0x31322e33, 0x4653413a,
+	  0x3e4e3d3a, 0x62483231, 0x58564e49, 0x385d5e5d, 0x656d6645,
+	  0x5b536c5a, 0xdbff595d, 0x16014300, 0x1c201818, 0x22223f20,
+	  0x4b58853f, 0x85858558, 0x85858585, 0x85858585, 0x85858585,
 	  0x85858585, 0x85858585, 0x85858585, 0x85858585, 0x85858585,
-	  0x85858585, 0x85858585, 0x85858585, 0xFF858585 },
-	{ 0x070B0043, 0x07080A08, 0x0A090A0B, 0x0D0B0C0C, 0x11121C11,
-	  0x23110F0F, 0x1C141A19, 0x2B2B2429, 0x27282428, 0x3842332E,
-	  0x313E302E, 0x4E392827, 0x46443E3A, 0x2C4A4A4A, 0x50565137,
-	  0x48425647, 0xDBFF474A, 0x12014300, 0x161A1313, 0x1C1C331A,
-	  0x3D486C33, 0x6C6C6C48, 0x6C6C6C6C, 0x6C6C6C6C, 0x6C6C6C6C,
-	  0x6C6C6C6C, 0x6C6C6C6C, 0x6C6C6C6C, 0x6C6C6C6C, 0x6C6C6C6C,
-	  0x6C6C6C6C, 0x6C6C6C6C, 0x6C6C6C6C, 0xFF6C6C6C },
-	{ 0x06090043, 0x05060706, 0x07070709, 0x0A09090A, 0x0D0E160D,
-	  0x1B0D0C0C, 0x16101413, 0x21221C20, 0x1E1F1C20, 0x2B332824,
-	  0x26302624, 0x3D2D1F1E, 0x3735302D, 0x22393A39, 0x3F443F2B,
-	  0x38334338, 0xDBFF3739, 0x0D014300, 0x11130E0E, 0x15152613,
-	  0x2D355026, 0x50505035, 0x50505050, 0x50505050, 0x50505050,
+	  0x85858585, 0x85858585, 0x85858585, 0xff858585 },
+	{ 0x070b0043, 0x07080a08, 0x0a090a0b, 0x0d0b0c0c, 0x11121c11,
+	  0x23110f0f, 0x1c141a19, 0x2b2b2429, 0x27282428, 0x3842332e,
+	  0x313e302e, 0x4e392827, 0x46443e3a, 0x2c4a4a4a, 0x50565137,
+	  0x48425647, 0xdbff474a, 0x12014300, 0x161a1313, 0x1c1c331a,
+	  0x3d486c33, 0x6c6c6c48, 0x6c6c6c6c, 0x6c6c6c6c, 0x6c6c6c6c,
+	  0x6c6c6c6c, 0x6c6c6c6c, 0x6c6c6c6c, 0x6c6c6c6c, 0x6c6c6c6c,
+	  0x6c6c6c6c, 0x6c6c6c6c, 0x6c6c6c6c, 0xff6c6c6c },
+	{ 0x06090043, 0x05060706, 0x07070709, 0x0a09090a, 0x0d0e160d,
+	  0x1b0d0c0c, 0x16101413, 0x21221c20, 0x1e1f1c20, 0x2b332824,
+	  0x26302624, 0x3d2d1f1e, 0x3735302d, 0x22393a39, 0x3f443f2b,
+	  0x38334338, 0xdbff3739, 0x0d014300, 0x11130e0e, 0x15152613,
+	  0x2d355026, 0x50505035, 0x50505050, 0x50505050, 0x50505050,
 	  0x50505050, 0x50505050, 0x50505050, 0x50505050, 0x50505050,
-	  0x50505050, 0x50505050, 0x50505050, 0xFF505050 },
-	{ 0x04060043, 0x03040504, 0x05040506, 0x07060606, 0x09090F09,
-	  0x12090808, 0x0F0A0D0D, 0x16161315, 0x14151315, 0x1D221B18,
-	  0x19201918, 0x281E1514, 0x2423201E, 0x17262726, 0x2A2D2A1C,
-	  0x25222D25, 0xDBFF2526, 0x09014300, 0x0B0D0A0A, 0x0E0E1A0D,
-	  0x1F25371A, 0x37373725, 0x37373737, 0x37373737, 0x37373737,
+	  0x50505050, 0x50505050, 0x50505050, 0xff505050 },
+	{ 0x04060043, 0x03040504, 0x05040506, 0x07060606, 0x09090f09,
+	  0x12090808, 0x0f0a0d0d, 0x16161315, 0x14151315, 0x1d221b18,
+	  0x19201918, 0x281e1514, 0x2423201e, 0x17262726, 0x2a2d2a1c,
+	  0x25222d25, 0xdbff2526, 0x09014300, 0x0b0d0a0a, 0x0e0e1a0d,
+	  0x1f25371a, 0x37373725, 0x37373737, 0x37373737, 0x37373737,
 	  0x37373737, 0x37373737, 0x37373737, 0x37373737, 0x37373737,
-	  0x37373737, 0x37373737, 0x37373737, 0xFF373737 },
+	  0x37373737, 0x37373737, 0x37373737, 0xff373737 },
 	{ 0x02030043, 0x01020202, 0x02020203, 0x03030303, 0x04040704,
-	  0x09040404, 0x07050606, 0x0B0B090A, 0x0A0A090A, 0x0E110D0C,
-	  0x0C100C0C, 0x140F0A0A, 0x1211100F, 0x0B131313, 0x1516150E,
-	  0x12111612, 0xDBFF1213, 0x04014300, 0x05060505, 0x07070D06,
-	  0x0F121B0D, 0x1B1B1B12, 0x1B1B1B1B, 0x1B1B1B1B, 0x1B1B1B1B,
-	  0x1B1B1B1B, 0x1B1B1B1B, 0x1B1B1B1B, 0x1B1B1B1B, 0x1B1B1B1B,
-	  0x1B1B1B1B, 0x1B1B1B1B, 0x1B1B1B1B, 0xFF1B1B1B },
+	  0x09040404, 0x07050606, 0x0b0b090a, 0x0a0a090a, 0x0e110d0c,
+	  0x0c100c0c, 0x140f0a0a, 0x1211100f, 0x0b131313, 0x1516150e,
+	  0x12111612, 0xdbff1213, 0x04014300, 0x05060505, 0x07070d06,
+	  0x0f121b0d, 0x1b1b1b12, 0x1b1b1b1b, 0x1b1b1b1b, 0x1b1b1b1b,
+	  0x1b1b1b1b, 0x1b1b1b1b, 0x1b1b1b1b, 0x1b1b1b1b, 0x1b1b1b1b,
+	  0x1b1b1b1b, 0x1b1b1b1b, 0x1b1b1b1b, 0xff1b1b1b },
 	{ 0x01020043, 0x01010101, 0x01010102, 0x02020202, 0x03030503,
-	  0x06030202, 0x05030404, 0x07070607, 0x06070607, 0x090B0908,
-	  0x080A0808, 0x0D0A0706, 0x0C0B0A0A, 0x070C0D0C, 0x0E0F0E09,
-	  0x0C0B0F0C, 0xDBFF0C0C, 0x03014300, 0x03040303, 0x04040804,
-	  0x0A0C1208, 0x1212120C, 0x12121212, 0x12121212, 0x12121212,
+	  0x06030202, 0x05030404, 0x07070607, 0x06070607, 0x090b0908,
+	  0x080a0808, 0x0d0a0706, 0x0c0b0a0a, 0x070c0d0c, 0x0e0f0e09,
+	  0x0c0b0f0c, 0xdbff0c0c, 0x03014300, 0x03040303, 0x04040804,
+	  0x0a0c1208, 0x1212120c, 0x12121212, 0x12121212, 0x12121212,
 	  0x12121212, 0x12121212, 0x12121212, 0x12121212, 0x12121212,
-	  0x12121212, 0x12121212, 0x12121212, 0xFF121212 },
+	  0x12121212, 0x12121212, 0x12121212, 0xff121212 },
 	{ 0x01020043, 0x01010101, 0x01010102, 0x02020202, 0x03030503,
-	  0x06030202, 0x05030404, 0x07070607, 0x06070607, 0x090B0908,
-	  0x080A0808, 0x0D0A0706, 0x0C0B0A0A, 0x070C0D0C, 0x0E0F0E09,
-	  0x0C0B0F0C, 0xDBFF0C0C, 0x02014300, 0x03030202, 0x04040703,
-	  0x080A0F07, 0x0F0F0F0A, 0x0F0F0F0F, 0x0F0F0F0F, 0x0F0F0F0F,
-	  0x0F0F0F0F, 0x0F0F0F0F, 0x0F0F0F0F, 0x0F0F0F0F, 0x0F0F0F0F,
-	  0x0F0F0F0F, 0x0F0F0F0F, 0x0F0F0F0F, 0xFF0F0F0F },
+	  0x06030202, 0x05030404, 0x07070607, 0x06070607, 0x090b0908,
+	  0x080a0808, 0x0d0a0706, 0x0c0b0a0a, 0x070c0d0c, 0x0e0f0e09,
+	  0x0c0b0f0c, 0xdbff0c0c, 0x02014300, 0x03030202, 0x04040703,
+	  0x080a0f07, 0x0f0f0f0a, 0x0f0f0f0f, 0x0f0f0f0f, 0x0f0f0f0f,
+	  0x0f0f0f0f, 0x0f0f0f0f, 0x0f0f0f0f, 0x0f0f0f0f, 0x0f0f0f0f,
+	  0x0f0f0f0f, 0x0f0f0f0f, 0x0f0f0f0f, 0xff0f0f0f },
 	{ 0x01010043, 0x01010101, 0x01010101, 0x01010101, 0x02020302,
 	  0x04020202, 0x03020303, 0x05050405, 0x05050405, 0x07080606,
-	  0x06080606, 0x0A070505, 0x09080807, 0x05090909, 0x0A0B0A07,
-	  0x09080B09, 0xDBFF0909, 0x02014300, 0x02030202, 0x03030503,
-	  0x07080C05, 0x0C0C0C08, 0x0C0C0C0C, 0x0C0C0C0C, 0x0C0C0C0C,
-	  0x0C0C0C0C, 0x0C0C0C0C, 0x0C0C0C0C, 0x0C0C0C0C, 0x0C0C0C0C,
-	  0x0C0C0C0C, 0x0C0C0C0C, 0x0C0C0C0C, 0xFF0C0C0C },
+	  0x06080606, 0x0a070505, 0x09080807, 0x05090909, 0x0a0b0a07,
+	  0x09080b09, 0xdbff0909, 0x02014300, 0x02030202, 0x03030503,
+	  0x07080c05, 0x0c0c0c08, 0x0c0c0c0c, 0x0c0c0c0c, 0x0c0c0c0c,
+	  0x0c0c0c0c, 0x0c0c0c0c, 0x0c0c0c0c, 0x0c0c0c0c, 0x0c0c0c0c,
+	  0x0c0c0c0c, 0x0c0c0c0c, 0x0c0c0c0c, 0xff0c0c0c },
 	{ 0x01010043, 0x01010101, 0x01010101, 0x01010101, 0x01010201,
 	  0x03010101, 0x02010202, 0x03030303, 0x03030303, 0x04050404,
 	  0x04050404, 0x06050303, 0x06050505, 0x03060606, 0x07070704,
-	  0x06050706, 0xDBFF0606, 0x01014300, 0x01020101, 0x02020402,
+	  0x06050706, 0xdbff0606, 0x01014300, 0x01020101, 0x02020402,
 	  0x05060904, 0x09090906, 0x09090909, 0x09090909, 0x09090909,
 	  0x09090909, 0x09090909, 0x09090909, 0x09090909, 0x09090909,
-	  0x09090909, 0x09090909, 0x09090909, 0xFF090909 },
+	  0x09090909, 0x09090909, 0x09090909, 0xff090909 },
 	{ 0x01010043, 0x01010101, 0x01010101, 0x01010101, 0x01010101,
 	  0x01010101, 0x01010101, 0x01010101, 0x01010101, 0x02020202,
 	  0x02020202, 0x03020101, 0x03020202, 0x01030303, 0x03030302,
-	  0x03020303, 0xDBFF0403, 0x01014300, 0x01010101, 0x01010201,
+	  0x03020303, 0xdbff0403, 0x01014300, 0x01010101, 0x01010201,
 	  0x03040602, 0x06060604, 0x06060606, 0x06060606, 0x06060606,
 	  0x06060606, 0x06060606, 0x06060606, 0x06060606, 0x06060606,
-	  0x06060606, 0x06060606, 0x06060606, 0xFF060606 }
+	  0x06060606, 0x06060606, 0x06060606, 0xff060606 }
 };
 
 static void aspeed_video_init_jpeg_table(u32 *table, bool yuv420)
@@ -387,7 +400,7 @@ static bool aspeed_video_engine_busy(struct aspeed_video *video)
 
 	if (!(seq_ctrl & VE_SEQ_CTRL_COMP_BUSY) ||
 	    !(seq_ctrl & VE_SEQ_CTRL_CAP_BUSY)) {
-		dev_info(video->dev, "video engine busy\n");
+		dev_err(video->dev, "video engine busy\n");
 		return true;
 	}
 
@@ -396,23 +409,34 @@ static bool aspeed_video_engine_busy(struct aspeed_video *video)
 
 static int aspeed_video_start_frame(struct aspeed_video *video)
 {
+	dma_addr_t addr;
+	unsigned long flags;
+	struct aspeed_video_buffer *buf;
+
 	if (aspeed_video_engine_busy(video))
 		return -EBUSY;
 
-	video->frame_idx = (video->frame_idx + 1) % 2;
+	spin_lock_irqsave(&video->lock, flags);
+	buf = list_first_entry_or_null(&video->buffers,
+				       struct aspeed_video_buffer, link);
+	if (!buf) {
+		spin_unlock_irqrestore(&video->lock, flags);
+		return -EPROTO;
+	}
+
+	set_bit(VIDEO_FRAME_INPRG, &video->flags);
+	addr = vb2_dma_contig_plane_dma_addr(&buf->vb.vb2_buf, 0);
+	spin_unlock_irqrestore(&video->lock, flags);
 
 	aspeed_video_write(video, VE_COMP_PROC_OFFSET, 0);
 	aspeed_video_write(video, VE_COMP_OFFSET, 0);
-	aspeed_video_write(video, VE_COMP_ADDR,
-			   video->comp[video->frame_idx].dma);
+	aspeed_video_write(video, VE_COMP_ADDR, addr);
 
-	set_bit(VIDEO_FRAME_TRIGGERED, &video->flags);
-
-	aspeed_video_update(video, VE_INTERRUPT_CTRL, 0xFFFFFFFF,
+	aspeed_video_update(video, VE_INTERRUPT_CTRL, 0xffffffff,
 			    VE_INTERRUPT_COMP_COMPLETE |
 			    VE_INTERRUPT_CAPTURE_COMPLETE);
 
-	aspeed_video_update(video, VE_SEQ_CTRL, 0xFFFFFFFF,
+	aspeed_video_update(video, VE_SEQ_CTRL, 0xffffffff,
 			    VE_SEQ_CTRL_TRIG_CAPTURE | VE_SEQ_CTRL_TRIG_COMP);
 
 	return 0;
@@ -421,11 +445,11 @@ static int aspeed_video_start_frame(struct aspeed_video *video)
 static void aspeed_video_start_mode_detect(struct aspeed_video *video)
 {
 	/* Enable mode detect interrupts */
-	aspeed_video_update(video, VE_INTERRUPT_CTRL, 0xFFFFFFFF,
+	aspeed_video_update(video, VE_INTERRUPT_CTRL, 0xffffffff,
 			    VE_INTERRUPT_MODE_DETECT);
 
 	/* Trigger mode detect */
-	aspeed_video_update(video, VE_SEQ_CTRL, 0xFFFFFFFF,
+	aspeed_video_update(video, VE_SEQ_CTRL, 0xffffffff,
 			    VE_SEQ_CTRL_TRIG_MODE_DET);
 }
 
@@ -463,6 +487,22 @@ static void aspeed_video_on(struct aspeed_video *video)
 	reset_control_deassert(video->rst);
 }
 
+static void aspeed_video_bufs_done(struct aspeed_video *video,
+				   enum vb2_buffer_state state)
+{
+	unsigned long flags;
+	struct aspeed_video_buffer *buf;
+
+	spin_lock_irqsave(&video->lock, flags);
+	list_for_each_entry(buf, &video->buffers, link) {
+		if (list_is_last(&buf->link, &video->buffers))
+			buf->vb.flags |= V4L2_BUF_FLAG_LAST;
+		vb2_buffer_done(&buf->vb.vb2_buf, state);
+	}
+	INIT_LIST_HEAD(&video->buffers);
+	spin_unlock_irqrestore(&video->lock, flags);
+}
+
 static irqreturn_t aspeed_video_irq(int irq, void *arg)
 {
 	struct aspeed_video *video = arg;
@@ -472,7 +512,7 @@ static irqreturn_t aspeed_video_irq(int irq, void *arg)
 		dev_info(video->dev, "irq with no client; disabling irqs\n");
 
 		aspeed_video_write(video, VE_INTERRUPT_CTRL, 0);
-		aspeed_video_write(video, VE_INTERRUPT_STATUS, 0xFFFFFFFF);
+		aspeed_video_write(video, VE_INTERRUPT_STATUS, 0xffffffff);
 		return IRQ_HANDLED;
 	}
 
@@ -480,8 +520,10 @@ static irqreturn_t aspeed_video_irq(int irq, void *arg)
 	if (sts & VE_INTERRUPT_MODE_DETECT_WD) {
 		dev_info(video->dev, "resolution changed; resetting\n");
 		set_bit(VIDEO_RES_CHANGE, &video->flags);
+		clear_bit(VIDEO_FRAME_INPRG, &video->flags);
 
 		aspeed_video_off(video);
+		aspeed_video_bufs_done(video, VB2_BUF_STATE_ERROR);
 
 		schedule_delayed_work(&video->res_work,
 				      RESOLUTION_CHANGE_DELAY);
@@ -500,23 +542,42 @@ static irqreturn_t aspeed_video_irq(int irq, void *arg)
 
 	if ((sts & VE_INTERRUPT_COMP_COMPLETE) &&
 	    (sts & VE_INTERRUPT_CAPTURE_COMPLETE)) {
-		video->frame_size = aspeed_video_read(video,
-						      VE_OFFSET_COMP_STREAM);
+		struct aspeed_video_buffer *buf;
+		u32 frame_size = aspeed_video_read(video,
+						   VE_OFFSET_COMP_STREAM);
+
+		spin_lock(&video->lock);
+		clear_bit(VIDEO_FRAME_INPRG, &video->flags);
+		buf = list_first_entry_or_null(&video->buffers,
+					       struct aspeed_video_buffer,
+					       link);
+		if (buf) {
+			vb2_set_plane_payload(&buf->vb.vb2_buf, 0, frame_size);
+
+			if (!list_is_last(&buf->link, &video->buffers)) {
+				buf->vb.vb2_buf.timestamp = ktime_get_ns();
+				buf->vb.sequence = video->sequence++;
+				buf->vb.field = V4L2_FIELD_NONE;
+				vb2_buffer_done(&buf->vb.vb2_buf,
+						VB2_BUF_STATE_DONE);
+				list_del(&buf->link);
+			}
+		}
+		spin_unlock(&video->lock);
 
+		aspeed_video_update(video, VE_SEQ_CTRL,
+				    ~(VE_SEQ_CTRL_TRIG_CAPTURE |
+				      VE_SEQ_CTRL_FORCE_IDLE |
+				      VE_SEQ_CTRL_TRIG_COMP), 0);
 		aspeed_video_update(video, VE_INTERRUPT_CTRL,
 				    ~(VE_INTERRUPT_COMP_COMPLETE |
 				      VE_INTERRUPT_CAPTURE_COMPLETE), 0);
 		aspeed_video_write(video, VE_INTERRUPT_STATUS,
 				   VE_INTERRUPT_COMP_COMPLETE |
 				   VE_INTERRUPT_CAPTURE_COMPLETE);
-		aspeed_video_update(video, VE_SEQ_CTRL,
-				    ~(VE_SEQ_CTRL_TRIG_CAPTURE |
-				      VE_SEQ_CTRL_FORCE_IDLE |
-				      VE_SEQ_CTRL_TRIG_COMP), 0);
 
-		set_bit(VIDEO_FRAME_AVAILABLE, &video->flags);
-		clear_bit(VIDEO_FRAME_TRIGGERED, &video->flags);
-		wake_up_interruptible_all(&video->wait);
+		if (test_bit(VIDEO_STREAMING, &video->flags) && buf)
+			aspeed_video_start_frame(video);
 	}
 
 	return IRQ_HANDLED;
@@ -551,10 +612,71 @@ static void aspeed_video_check_polarity(struct aspeed_video *video)
 		if (vsync_counter < 0)
 			ctrl = VE_CTRL_VSYNC_POL;
 
-		aspeed_video_update(video, VE_CTRL, 0xFFFFFFFF, ctrl);
+		aspeed_video_update(video, VE_CTRL, 0xffffffff, ctrl);
 	}
 }
 
+static bool aspeed_video_alloc_buf(struct aspeed_video *video,
+				   struct aspeed_video_addr *addr,
+				   unsigned int size)
+{
+	addr->virt = dma_alloc_coherent(video->dev, size, &addr->dma,
+					GFP_KERNEL);
+	if (!addr->virt)
+		return false;
+
+	addr->size = size;
+	return true;
+}
+
+static void aspeed_video_free_buf(struct aspeed_video *video,
+				  struct aspeed_video_addr *addr)
+{
+	dma_free_coherent(video->dev, addr->size, addr->virt, addr->dma);
+	addr->size = 0;
+	addr->dma = 0ULL;
+	addr->virt = NULL;
+}
+
+/*
+ * Get the minimum HW-supported compression buffer size for the frame size.
+ * Assume worst-case JPEG compression size is 1/8 raw size. This should be
+ * plenty even for maximum quality; any worse and the engine will simply return
+ * incomplete JPEGs.
+ */
+static void aspeed_video_calc_compressed_size(struct aspeed_video *video)
+{
+	int i, j;
+	u32 compression_buffer_size_reg = 0;
+	unsigned int size;
+	const unsigned int num_compression_packets = 4;
+	const unsigned int compression_packet_size = 1024;
+	const unsigned int max_compressed_size =
+		video->width * video->height / 2;	/* 4 Bpp / 8 */
+
+	video->max_compressed_size = UINT_MAX;
+
+	for (i = 0; i < 6; ++i) {
+		for (j = 0; j < 8; ++j) {
+			size = (num_compression_packets << i) *
+				(compression_packet_size << j);
+			if (size < max_compressed_size)
+				continue;
+
+			if (size < video->max_compressed_size) {
+				compression_buffer_size_reg = (i << 3) | j;
+				video->max_compressed_size = size;
+			}
+		}
+	}
+
+	aspeed_video_write(video, VE_STREAM_BUF_SIZE,
+			   compression_buffer_size_reg);
+
+	dev_dbg(video->dev, "max compressed size: %x\n",
+		video->max_compressed_size);
+}
+
 #define res_check(v) test_and_clear_bit(VIDEO_MODE_DETECT_DONE, &(v)->flags)
 
 static int aspeed_video_get_resolution(struct aspeed_video *video)
@@ -565,9 +687,27 @@ static int aspeed_video_get_resolution(struct aspeed_video *video)
 	unsigned int bottom;
 	unsigned int left;
 	unsigned int right;
+	unsigned int size;
 	unsigned int top;
 	u32 src_lr_edge;
 	u32 src_tb_edge;
+	struct aspeed_video_addr src;
+
+	if (video->srcs[1].size)
+		aspeed_video_free_buf(video, &video->srcs[1]);
+
+	if (video->srcs[0].size >= VE_MAX_SRC_BUFFER_SIZE) {
+		src = video->srcs[0];
+	} else {
+		if (video->srcs[0].size)
+			aspeed_video_free_buf(video, &video->srcs[0]);
+
+		if (!aspeed_video_alloc_buf(video, &src,
+					    VE_MAX_SRC_BUFFER_SIZE))
+			goto err_mem;
+	}
+
+	aspeed_video_write(video, VE_SRC0_ADDR, src.dma);
 
 	video->width = 0;
 	video->height = 0;
@@ -587,7 +727,7 @@ static int aspeed_video_get_resolution(struct aspeed_video *video)
 		if (!rc) {
 			dev_err(video->dev, "timed out on 1st mode detect\n");
 			aspeed_video_disable_mode_detect(video);
-			return -ETIME;
+			return -ETIMEDOUT;
 		}
 
 		/* Disable mode detect in order to re-trigger */
@@ -604,7 +744,7 @@ static int aspeed_video_get_resolution(struct aspeed_video *video)
 		if (!rc) {
 			dev_err(video->dev, "timed out on 2nd mode detect\n");
 			aspeed_video_disable_mode_detect(video);
-			return -ETIME;
+			return -ETIMEDOUT;
 		}
 
 		src_lr_edge = aspeed_video_read(video, VE_SRC_LR_EDGE_DET);
@@ -627,22 +767,26 @@ static int aspeed_video_get_resolution(struct aspeed_video *video)
 
 	if (invalid_resolution) {
 		dev_err(video->dev, "invalid resolution detected\n");
-		return -EMSGSIZE;
+		return -ERANGE;
 	}
 
 	video->height = (bottom - top) + 1;
 	video->width = (right - left) + 1;
+	size = video->height * video->width;
 
 	/* Don't use direct mode below 1024 x 768 (irqs don't fire) */
-	if (video->height * video->width < DIRECT_FETCH_THRESHOLD) {
+	if (size < DIRECT_FETCH_THRESHOLD) {
 		aspeed_video_write(video, VE_TGS_0,
 				   FIELD_PREP(VE_TGS_FIRST, left - 1) |
 				   FIELD_PREP(VE_TGS_LAST, right));
 		aspeed_video_write(video, VE_TGS_1,
 				   FIELD_PREP(VE_TGS_FIRST, top) |
 				   FIELD_PREP(VE_TGS_LAST, bottom + 1));
-		aspeed_video_update(video, VE_CTRL,
-				    ~VE_CTRL_DIRECT_FETCH, VE_CTRL_INT_DE);
+		aspeed_video_update(video, VE_CTRL, 0xffffffff,
+				    VE_CTRL_INT_DE);
+	} else {
+		aspeed_video_update(video, VE_CTRL, 0xffffffff,
+				    VE_CTRL_DIRECT_FETCH);
 	}
 
 	aspeed_video_write(video, VE_CAP_WINDOW,
@@ -651,15 +795,49 @@ static int aspeed_video_get_resolution(struct aspeed_video *video)
 			   video->width << 16 | video->height);
 	aspeed_video_write(video, VE_SRC_SCANLINE_OFFSET, video->width * 4);
 
-	aspeed_video_update(video, VE_INTERRUPT_CTRL, 0xFFFFFFFF,
+	aspeed_video_update(video, VE_INTERRUPT_CTRL, 0xffffffff,
 			    VE_INTERRUPT_MODE_DETECT_WD);
-	aspeed_video_update(video, VE_SEQ_CTRL, 0xFFFFFFFF,
-			    VE_SEQ_CTRL_EN_WATCHDOG);
+	aspeed_video_update(video, VE_SEQ_CTRL, 0xffffffff,
+			    VE_SEQ_CTRL_AUTO_COMP | VE_SEQ_CTRL_EN_WATCHDOG);
 
 	dev_dbg(video->dev, "got resolution[%dx%d]\n", video->width,
 		video->height);
 
+	size *= 4;
+	if (size == src.size / 2) {
+		aspeed_video_write(video, VE_SRC1_ADDR, src.dma + size);
+		video->srcs[0] = src;
+	} else if (size == src.size) {
+		video->srcs[0] = src;
+
+		if (!aspeed_video_alloc_buf(video, &video->srcs[1], size))
+			goto err_mem;
+
+		aspeed_video_write(video, VE_SRC1_ADDR, video->srcs[1].dma);
+	} else {
+		aspeed_video_free_buf(video, &src);
+
+		if (!aspeed_video_alloc_buf(video, &video->srcs[0], size))
+			goto err_mem;
+
+		if (!aspeed_video_alloc_buf(video, &video->srcs[1], size))
+			goto err_mem;
+
+		aspeed_video_write(video, VE_SRC0_ADDR, video->srcs[0].dma);
+		aspeed_video_write(video, VE_SRC1_ADDR, video->srcs[1].dma);
+	}
+
+	aspeed_video_calc_compressed_size(video);
+
 	return 0;
+
+err_mem:
+	dev_err(video->dev, "failed to allocate source buffers\n");
+
+	if (video->srcs[0].size)
+		aspeed_video_free_buf(video, &video->srcs[0]);
+
+	return -ENOMEM;
 }
 
 static void aspeed_video_init_regs(struct aspeed_video *video)
@@ -667,8 +845,8 @@ static void aspeed_video_init_regs(struct aspeed_video *video)
 	u32 comp_ctrl = VE_COMP_CTRL_RSVD |
 		FIELD_PREP(VE_COMP_CTRL_DCT_LUM, video->jpeg_quality) |
 		FIELD_PREP(VE_COMP_CTRL_DCT_CHR, video->jpeg_quality | 0x10);
-	u32 ctrl = VE_CTRL_DIRECT_FETCH | VE_CTRL_AUTO_OR_CURSOR;
-	u32 seq_ctrl = VE_SEQ_CTRL_AUTO_COMP | VE_SEQ_CTRL_JPEG_MODE;
+	u32 ctrl = VE_CTRL_AUTO_OR_CURSOR;
+	u32 seq_ctrl = VE_SEQ_CTRL_JPEG_MODE;
 
 	if (video->frame_rate)
 		ctrl |= FIELD_PREP(VE_CTRL_FRC, video->frame_rate);
@@ -681,20 +859,12 @@ static void aspeed_video_init_regs(struct aspeed_video *video)
 
 	/* Disable interrupts */
 	aspeed_video_write(video, VE_INTERRUPT_CTRL, 0);
-	aspeed_video_write(video, VE_INTERRUPT_STATUS, 0xFFFFFFFF);
+	aspeed_video_write(video, VE_INTERRUPT_STATUS, 0xffffffff);
 
 	/* Clear the offset */
 	aspeed_video_write(video, VE_COMP_PROC_OFFSET, 0);
 	aspeed_video_write(video, VE_COMP_OFFSET, 0);
 
-	/* Set memory restrictions */
-	aspeed_video_write(video, VE_MEM_RESTRICT_START, video->min);
-	aspeed_video_write(video, VE_MEM_RESTRICT_END, video->max);
-
-	/* Set buffer addresses */
-	aspeed_video_write(video, VE_SRC0_ADDR, video->srcs[0].dma);
-	aspeed_video_write(video, VE_SRC1_ADDR, video->srcs[1].dma);
-	aspeed_video_write(video, VE_COMP_ADDR, video->comp[0].dma);
 	aspeed_video_write(video, VE_JPEG_ADDR, video->jpeg.dma);
 
 	/* Set control registers */
@@ -702,9 +872,6 @@ static void aspeed_video_init_regs(struct aspeed_video *video)
 	aspeed_video_write(video, VE_CTRL, ctrl);
 	aspeed_video_write(video, VE_COMP_CTRL, comp_ctrl);
 
-	/* Compression buffer size; 128K packet * 8 packets */
-	aspeed_video_write(video, VE_STREAM_BUF_SIZE, 0xf);
-
 	/* Don't downscale */
 	aspeed_video_write(video, VE_SCALING_FACTOR, 0x10001000);
 	aspeed_video_write(video, VE_SCALING_FILTER0, 0x00200000);
@@ -716,136 +883,9 @@ static void aspeed_video_init_regs(struct aspeed_video *video)
 	aspeed_video_write(video, VE_MODE_DETECT, 0x22666500);
 }
 
-static int aspeed_video_allocate_cma(struct aspeed_video *video)
-{
-	video->srcs[0].virt = dma_alloc_coherent(video->dev,
-						 VE_SRC_BUFFER_SIZE,
-						 &video->srcs[0].dma,
-						 GFP_KERNEL);
-	if (!video->srcs[0].virt) {
-		dev_err(video->dev,
-			"Failed to allocate source buffer 0, size[%x]\n",
-			VE_SRC_BUFFER_SIZE);
-		goto err;
-	}
-
-	video->srcs[1].virt = dma_alloc_coherent(video->dev,
-						 VE_SRC_BUFFER_SIZE,
-						 &video->srcs[1].dma,
-						 GFP_KERNEL);
-	if (!video->srcs[1].virt) {
-		dev_err(video->dev,
-			"Failed to allocate source buffer 1, size[%x]\n",
-			VE_SRC_BUFFER_SIZE);
-		goto free_src0;
-	}
-
-	video->comp[0].virt = dma_alloc_coherent(video->dev,
-						 VE_COMP_BUFFER_SIZE,
-						 &video->comp[0].dma,
-						 GFP_KERNEL);
-	if (!video->comp[0].virt) {
-		dev_err(video->dev,
-			"Failed to allocate compression buffer 0, size[%x]\n",
-			VE_COMP_BUFFER_SIZE);
-		goto free_src1;
-	}
-
-	video->comp[1].virt = dma_alloc_coherent(video->dev,
-						 VE_COMP_BUFFER_SIZE,
-						 &video->comp[1].dma,
-						 GFP_KERNEL);
-	if (!video->comp[0].virt) {
-		dev_err(video->dev,
-			"Failed to allocate compression buffer 1, size[%x]\n",
-			VE_COMP_BUFFER_SIZE);
-		goto free_comp0;
-	}
-
-	video->jpeg.virt = dma_alloc_coherent(video->dev, VE_JPEG_BUFFER_SIZE,
-					      &video->jpeg.dma, GFP_KERNEL);
-	if (!video->jpeg.virt) {
-		dev_err(video->dev,
-			"Failed to allocate JPEG buffer, size[%x]\n",
-			VE_JPEG_BUFFER_SIZE);
-		goto free_comp1;
-	}
-
-	aspeed_video_init_jpeg_table(video->jpeg.virt, video->yuv420);
-
-	/*
-	 * Calculate the memory restrictions. Don't consider the JPEG header
-	 * buffer since HW doesn't need to write to it.
-	 */
-	video->max = max(video->srcs[0].dma + VE_SRC_BUFFER_SIZE,
-			 video->srcs[1].dma + VE_SRC_BUFFER_SIZE);
-	video->max = max(video->max, video->comp[0].dma + VE_COMP_BUFFER_SIZE);
-	video->max = max(video->max, video->comp[1].dma + VE_COMP_BUFFER_SIZE);
-
-	video->min = min(video->srcs[0].dma, video->srcs[1].dma);
-	video->min = min(video->min, video->comp[0].dma);
-	video->min = min(video->min, video->comp[1].dma);
-
-	return 0;
-
-free_comp1:
-	dma_free_coherent(video->dev, VE_COMP_BUFFER_SIZE, video->comp[1].virt,
-			  video->comp[1].dma);
-	video->comp[1].dma = 0ULL;
-	video->comp[1].virt = NULL;
-
-free_comp0:
-	dma_free_coherent(video->dev, VE_COMP_BUFFER_SIZE, video->comp[0].virt,
-			  video->comp[0].dma);
-	video->comp[0].dma = 0ULL;
-	video->comp[0].virt = NULL;
-
-free_src1:
-	dma_free_coherent(video->dev, VE_SRC_BUFFER_SIZE, video->srcs[1].virt,
-			  video->srcs[1].dma);
-	video->srcs[1].dma = 0ULL;
-	video->srcs[1].virt = NULL;
-
-free_src0:
-	dma_free_coherent(video->dev, VE_SRC_BUFFER_SIZE, video->srcs[0].virt,
-			  video->srcs[0].dma);
-	video->srcs[0].dma = 0ULL;
-	video->srcs[0].virt = NULL;
-err:
-	return -ENOMEM;
-}
-
-static void aspeed_video_free_cma(struct aspeed_video *video)
-{
-	dma_free_coherent(video->dev, VE_JPEG_BUFFER_SIZE, video->jpeg.virt,
-			  video->jpeg.dma);
-	dma_free_coherent(video->dev, VE_COMP_BUFFER_SIZE, video->comp[1].virt,
-			  video->comp[1].dma);
-	dma_free_coherent(video->dev, VE_COMP_BUFFER_SIZE, video->comp[0].virt,
-			  video->comp[0].dma);
-	dma_free_coherent(video->dev, VE_SRC_BUFFER_SIZE, video->srcs[1].virt,
-			  video->srcs[1].dma);
-	dma_free_coherent(video->dev, VE_SRC_BUFFER_SIZE, video->srcs[0].virt,
-			  video->srcs[0].dma);
-
-	video->srcs[0].dma = 0ULL;
-	video->srcs[0].virt = NULL;
-	video->srcs[1].dma = 0ULL;
-	video->srcs[1].virt = NULL;
-	video->comp[0].dma = 0ULL;
-	video->comp[0].virt = NULL;
-	video->comp[1].dma = 0ULL;
-	video->comp[1].virt = NULL;
-	video->jpeg.dma = 0ULL;
-	video->jpeg.virt = NULL;
-}
-
 static int aspeed_video_start(struct aspeed_video *video)
 {
-	int rc = aspeed_video_allocate_cma(video);
-
-	if (rc)
-		return rc;
+	int rc;
 
 	aspeed_video_on(video);
 
@@ -853,15 +893,15 @@ static int aspeed_video_start(struct aspeed_video *video)
 
 	rc = aspeed_video_get_resolution(video);
 	if (rc)
-		aspeed_video_free_cma(video);
-
-	video->v4l2_fmt.fmt.pix.width = video->width;
-	video->v4l2_fmt.fmt.pix.height = video->height;
-	video->v4l2_fmt.fmt.pix.sizeimage = video->width * video->height * 4;
+		return rc;
 
-	clear_bit(VIDEO_FRAME_TRIGGERED, &video->flags);
+	video->pix_fmt.width = video->width;
+	video->pix_fmt.height = video->height;
+	video->pix_fmt.sizeimage = video->max_compressed_size;
+	video->timings.width = video->width;
+	video->timings.height = video->height;
 
-	return rc;
+	return 0;
 }
 
 static void aspeed_video_stop(struct aspeed_video *video)
@@ -870,16 +910,20 @@ static void aspeed_video_stop(struct aspeed_video *video)
 
 	aspeed_video_off(video);
 
-	aspeed_video_free_cma(video);
+	if (video->srcs[0].size)
+		aspeed_video_free_buf(video, &video->srcs[0]);
+
+	if (video->srcs[1].size)
+		aspeed_video_free_buf(video, &video->srcs[1]);
 
-	clear_bit(VIDEO_FRAME_AVAILABLE, &video->flags);
+	video->flags = 0;
 }
 
 static int aspeed_video_querycap(struct file *file, void *fh,
 				 struct v4l2_capability *cap)
 {
-	strlcpy(cap->driver, DEVICE_NAME, sizeof(cap->driver));
-	strlcpy(cap->card, "Aspeed Video Engine", sizeof(cap->card));
+	strscpy(cap->driver, DEVICE_NAME, sizeof(cap->driver));
+	strscpy(cap->card, "Aspeed Video Engine", sizeof(cap->card));
 	snprintf(cap->bus_info, sizeof(cap->bus_info), "platform:%s",
 		 DEVICE_NAME);
 
@@ -893,9 +937,6 @@ static int aspeed_video_enum_format(struct file *file, void *fh,
 		return -EINVAL;
 
 	f->pixelformat = V4L2_PIX_FMT_JPEG;
-	strlcpy(f->description, "JPEG", sizeof(f->description));
-	f->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-	f->flags = V4L2_FMT_FLAG_COMPRESSED;
 
 	return 0;
 }
@@ -905,41 +946,7 @@ static int aspeed_video_get_format(struct file *file, void *fh,
 {
 	struct aspeed_video *video = video_drvdata(file);
 
-	*f = video->v4l2_fmt;
-
-	return 0;
-}
-
-static int aspeed_video_set_format(struct file *file, void *fh,
-				   struct v4l2_format *f)
-{
-	struct aspeed_video *video = video_drvdata(file);
-
-	if (f->fmt.pix.width == video->width)
-		video->v4l2_fmt.fmt.pix.width = video->width;
-
-	if (f->fmt.pix.height == video->height)
-		video->v4l2_fmt.fmt.pix.height = video->height;
-
-	return aspeed_video_get_format(file, fh, f);
-}
-
-static int aspeed_video_try_format(struct file *file, void *fh,
-				   struct v4l2_format *f)
-{
-	int rc;
-	struct aspeed_video *video = video_drvdata(file);
-	struct v4l2_pix_format pix = f->fmt.pix;
-
-	rc = aspeed_video_get_format(file, fh, f);
-	if (rc)
-		return rc;
-
-	if (pix.width == video->width)
-		f->fmt.pix.width = video->width;
-
-	if (pix.height == video->height)
-		f->fmt.pix.height = video->height;
+	f->fmt.pix = video->pix_fmt;
 
 	return 0;
 }
@@ -950,8 +957,10 @@ static int aspeed_video_enum_input(struct file *file, void *fh,
 	if (inp->index)
 		return -EINVAL;
 
-	strlcpy(inp->name, "Host VGA capture", sizeof(inp->name));
+	strscpy(inp->name, "Host VGA capture", sizeof(inp->name));
 	inp->type = V4L2_INPUT_TYPE_CAMERA;
+	inp->capabilities = V4L2_IN_CAP_DV_TIMINGS;
+	inp->status = V4L2_IN_ST_NO_SIGNAL | V4L2_IN_ST_NO_SYNC;
 
 	return 0;
 }
@@ -976,8 +985,8 @@ static int aspeed_video_get_parm(struct file *file, void *fh,
 {
 	struct aspeed_video *video = video_drvdata(file);
 
-	a->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
 	a->parm.capture.capability = V4L2_CAP_TIMEPERFRAME;
+	a->parm.capture.readbuffers = 3;
 	a->parm.capture.timeperframe.numerator = 1;
 	if (!video->frame_rate)
 		a->parm.capture.timeperframe.denominator = MAX_FRAME_RATE + 1;
@@ -990,27 +999,26 @@ static int aspeed_video_get_parm(struct file *file, void *fh,
 static int aspeed_video_set_parm(struct file *file, void *fh,
 				 struct v4l2_streamparm *a)
 {
-	int frame_rate;
+	unsigned int frame_rate = 0;
 	struct aspeed_video *video = video_drvdata(file);
 
-	if (a->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
-		return -EINVAL;
-
 	a->parm.capture.capability = V4L2_CAP_TIMEPERFRAME;
+	a->parm.capture.readbuffers = 3;
 
-	if (a->parm.capture.timeperframe.numerator) {
+	if (a->parm.capture.timeperframe.numerator)
 		frame_rate = a->parm.capture.timeperframe.denominator /
 			a->parm.capture.timeperframe.numerator;
-	} else {
-		frame_rate = 0;
-		a->parm.capture.timeperframe.numerator = 1;
-	}
 
-	if (frame_rate < 0 || frame_rate > MAX_FRAME_RATE)
+	if (!frame_rate || frame_rate > MAX_FRAME_RATE) {
 		frame_rate = 0;
 
-	if (!frame_rate)
+		/*
+		 * Set to max + 1 to differentiate between max and 0, which
+		 * means "don't care".
+		 */
 		a->parm.capture.timeperframe.denominator = MAX_FRAME_RATE + 1;
+		a->parm.capture.timeperframe.numerator = 1;
+	}
 
 	if (video->frame_rate != frame_rate) {
 		video->frame_rate = frame_rate;
@@ -1026,26 +1034,14 @@ static int aspeed_video_enum_framesizes(struct file *file, void *fh,
 {
 	struct aspeed_video *video = video_drvdata(file);
 
-	if (fsize->pixel_format != V4L2_PIX_FMT_JPEG)
+	if (fsize->index)
 		return -EINVAL;
 
-	switch (fsize->index) {
-	case 0:
-		fsize->discrete.width = video->v4l2_fmt.fmt.pix.width;
-		fsize->discrete.height = video->v4l2_fmt.fmt.pix.height;
-		break;
-	case 1:
-		if (video->width == video->v4l2_fmt.fmt.pix.width &&
-		    video->height == video->v4l2_fmt.fmt.pix.height)
-			return -EINVAL;
-
-		fsize->discrete.width = video->width;
-		fsize->discrete.height = video->height;
-		break;
-	default:
+	if (fsize->pixel_format != V4L2_PIX_FMT_JPEG)
 		return -EINVAL;
-	}
 
+	fsize->discrete.width = video->pix_fmt.width;
+	fsize->discrete.height = video->pix_fmt.height;
 	fsize->type = V4L2_FRMSIZE_TYPE_DISCRETE;
 
 	return 0;
@@ -1076,20 +1072,130 @@ static int aspeed_video_enum_frameintervals(struct file *file, void *fh,
 	return 0;
 }
 
+static int aspeed_video_set_dv_timings(struct file *file, void *fh,
+				       struct v4l2_dv_timings *timings)
+{
+	struct aspeed_video *video = video_drvdata(file);
+
+	if (video->width != timings->bt.width ||
+	    video->height != timings->bt.height)
+		return -EINVAL;
+
+	video->pix_fmt.width = timings->bt.width;
+	video->pix_fmt.height = timings->bt.height;
+	video->pix_fmt.sizeimage = video->max_compressed_size;
+	video->timings.width = timings->bt.width;
+	video->timings.height = timings->bt.height;
+
+	timings->type = V4L2_DV_BT_656_1120;
+
+	return 0;
+}
+
+static int aspeed_video_get_dv_timings(struct file *file, void *fh,
+				       struct v4l2_dv_timings *timings)
+{
+	struct aspeed_video *video = video_drvdata(file);
+
+	timings->type = V4L2_DV_BT_656_1120;
+	timings->bt = video->timings;
+
+	return 0;
+}
+
+static int aspeed_video_query_dv_timings(struct file *file, void *fh,
+					 struct v4l2_dv_timings *timings)
+{
+	int rc;
+	struct aspeed_video *video = video_drvdata(file);
+
+	if (file->f_flags & O_NONBLOCK) {
+		if (test_bit(VIDEO_RES_CHANGE, &video->flags))
+			return -EAGAIN;
+	} else {
+		rc = wait_event_interruptible(video->wait,
+					      !test_bit(VIDEO_RES_CHANGE,
+							&video->flags));
+		if (rc)
+			return -EINTR;
+	}
+
+	timings->type = V4L2_DV_BT_656_1120;
+	timings->bt = video->timings;
+	timings->bt.width = video->width;
+	timings->bt.height = video->height;
+
+	return 0;
+}
+
+static int aspeed_video_enum_dv_timings(struct file *file, void *fh,
+					struct v4l2_enum_dv_timings *timings)
+{
+	if (timings->index)
+		return -EINVAL;
+
+	return aspeed_video_get_dv_timings(file, fh, &timings->timings);
+}
+
+static int aspeed_video_dv_timings_cap(struct file *file, void *fh,
+				       struct v4l2_dv_timings_cap *cap)
+{
+	struct aspeed_video *video = video_drvdata(file);
+
+	cap->type = V4L2_DV_BT_656_1120;
+	cap->bt.capabilities = V4L2_DV_BT_CAP_PROGRESSIVE;
+	cap->bt.min_width = video->width;
+	cap->bt.max_width = video->width;
+	cap->bt.min_height = video->height;
+	cap->bt.max_height = video->height;
+
+	return 0;
+}
+
+static int aspeed_video_sub_event(struct v4l2_fh *fh,
+				  const struct v4l2_event_subscription *sub)
+{
+	switch (sub->type) {
+	case V4L2_EVENT_SOURCE_CHANGE:
+		return v4l2_src_change_event_subscribe(fh, sub);
+	}
+
+	return v4l2_ctrl_subscribe_event(fh, sub);
+}
+
 static const struct v4l2_ioctl_ops aspeed_video_ioctl_ops = {
 	.vidioc_querycap = aspeed_video_querycap,
+
 	.vidioc_enum_fmt_vid_cap = aspeed_video_enum_format,
 	.vidioc_g_fmt_vid_cap = aspeed_video_get_format,
-	.vidioc_s_fmt_vid_cap = aspeed_video_set_format,
-	.vidioc_try_fmt_vid_cap = aspeed_video_try_format,
+	.vidioc_s_fmt_vid_cap = aspeed_video_get_format,
+	.vidioc_try_fmt_vid_cap = aspeed_video_get_format,
+
+	.vidioc_reqbufs = vb2_ioctl_reqbufs,
+	.vidioc_querybuf = vb2_ioctl_querybuf,
+	.vidioc_qbuf = vb2_ioctl_qbuf,
+	.vidioc_dqbuf = vb2_ioctl_dqbuf,
+	.vidioc_create_bufs = vb2_ioctl_create_bufs,
+	.vidioc_prepare_buf = vb2_ioctl_prepare_buf,
+	.vidioc_streamon = vb2_ioctl_streamon,
+	.vidioc_streamoff = vb2_ioctl_streamoff,
+
 	.vidioc_enum_input = aspeed_video_enum_input,
 	.vidioc_g_input = aspeed_video_get_input,
 	.vidioc_s_input = aspeed_video_set_input,
+
 	.vidioc_g_parm = aspeed_video_get_parm,
 	.vidioc_s_parm = aspeed_video_set_parm,
 	.vidioc_enum_framesizes = aspeed_video_enum_framesizes,
 	.vidioc_enum_frameintervals = aspeed_video_enum_frameintervals,
-	.vidioc_subscribe_event = v4l2_ctrl_subscribe_event,
+
+	.vidioc_s_dv_timings = aspeed_video_set_dv_timings,
+	.vidioc_g_dv_timings = aspeed_video_get_dv_timings,
+	.vidioc_query_dv_timings = aspeed_video_query_dv_timings,
+	.vidioc_enum_dv_timings = aspeed_video_enum_dv_timings,
+	.vidioc_dv_timings_cap = aspeed_video_dv_timings_cap,
+
+	.vidioc_subscribe_event = aspeed_video_sub_event,
 	.vidioc_unsubscribe_event = v4l2_event_unsubscribe,
 };
 
@@ -1109,7 +1215,7 @@ static void aspeed_video_update_subsampling(struct aspeed_video *video)
 		aspeed_video_init_jpeg_table(video->jpeg.virt, video->yuv420);
 
 	if (video->yuv420)
-		aspeed_video_update(video, VE_SEQ_CTRL, 0xFFFFFFFF,
+		aspeed_video_update(video, VE_SEQ_CTRL, 0xffffffff,
 				    VE_SEQ_CTRL_YUV420);
 	else
 		aspeed_video_update(video, VE_SEQ_CTRL, ~VE_SEQ_CTRL_YUV420,
@@ -1120,26 +1226,20 @@ static int aspeed_video_set_ctrl(struct v4l2_ctrl *ctrl)
 {
 	struct aspeed_video *video = container_of(ctrl->handler,
 						  struct aspeed_video,
-						  v4l2_ctrl);
+						  ctrl_handler);
 
 	switch (ctrl->id) {
 	case V4L2_CID_JPEG_COMPRESSION_QUALITY:
-		if (video->jpeg_quality != ctrl->val) {
-			video->jpeg_quality = ctrl->val;
-			aspeed_video_update_jpeg_quality(video);
-		}
+		video->jpeg_quality = ctrl->val;
+		aspeed_video_update_jpeg_quality(video);
 		break;
 	case V4L2_CID_JPEG_CHROMA_SUBSAMPLING:
 		if (ctrl->val == V4L2_JPEG_CHROMA_SUBSAMPLING_420) {
-			if (!video->yuv420) {
-				video->yuv420 = true;
-				aspeed_video_update_subsampling(video);
-			}
+			video->yuv420 = true;
+			aspeed_video_update_subsampling(video);
 		} else {
-			if (video->yuv420) {
-				video->yuv420 = false;
-				aspeed_video_update_subsampling(video);
-			}
+			video->yuv420 = false;
+			aspeed_video_update_subsampling(video);
 		}
 		break;
 	default:
@@ -1169,12 +1269,20 @@ static void aspeed_video_resolution_work(struct work_struct *work)
 	aspeed_video_init_regs(video);
 
 	rc = aspeed_video_get_resolution(video);
-	if (rc) {
+	if (rc)
 		dev_err(video->dev,
 			"resolution changed; couldn't get new resolution\n");
-	} else {
-		video->frame_idx = 0;
-		clear_bit(VIDEO_FRAME_TRIGGERED, &video->flags);
+	else if (test_bit(VIDEO_STREAMING, &video->flags))
+		aspeed_video_start_frame(video);
+
+	if (video->width != video->pix_fmt.width ||
+	    video->height != video->pix_fmt.height) {
+		static const struct v4l2_event ev = {
+			.type = V4L2_EVENT_SOURCE_CHANGE,
+			.u.src_change.changes = V4L2_EVENT_SRC_CH_RESOLUTION,
+		};
+
+		v4l2_event_queue(&video->vdev, &ev);
 	}
 
 done:
@@ -1182,76 +1290,25 @@ static void aspeed_video_resolution_work(struct work_struct *work)
 	wake_up_interruptible_all(&video->wait);
 }
 
-static bool aspeed_video_frame_available(struct aspeed_video *video)
-{
-	if (!test_and_clear_bit(VIDEO_FRAME_AVAILABLE, &video->flags)) {
-		if (!test_bit(VIDEO_FRAME_TRIGGERED, &video->flags))
-			aspeed_video_start_frame(video);
-
-		return false;
-	}
-
-	return true;
-}
-
-static ssize_t aspeed_video_file_read(struct file *file, char __user *buf,
-				      size_t count, loff_t *ppos)
-{
-	int rc;
-	int fidx;
-	size_t size;
-	struct aspeed_video *video = video_drvdata(file);
-
-	if (mutex_lock_interruptible(&video->video_lock))
-		return -EINTR;
-
-	if (file->f_flags & O_NONBLOCK) {
-		if (!aspeed_video_frame_available(video)) {
-			rc = -EAGAIN;
-			goto unlock;
-		} else {
-			goto ready;
-		}
-	}
-
-	rc = wait_event_interruptible(video->wait,
-				      aspeed_video_frame_available(video));
-	if (rc) {
-		rc = -EINTR;
-		goto unlock;
-	}
-
-ready:
-	fidx = video->frame_idx;
-	size = min_t(size_t, video->frame_size, count);
-	aspeed_video_start_frame(video);
-
-	if (copy_to_user(buf, video->comp[fidx].virt, size)) {
-		rc = -EFAULT;
-		goto unlock;
-	}
-
-	rc = size;
-
-unlock:
-	mutex_unlock(&video->video_lock);
-	return rc;
-}
-
 static int aspeed_video_open(struct file *file)
 {
 	int rc;
 	struct aspeed_video *video = video_drvdata(file);
 
+	mutex_lock(&video->video_lock);
+
 	if (atomic_inc_return(&video->clients) == 1) {
 		rc = aspeed_video_start(video);
 		if (rc) {
 			dev_err(video->dev, "Failed to start video engine\n");
 			atomic_dec(&video->clients);
+			mutex_unlock(&video->video_lock);
 			return rc;
 		}
 	}
 
+	mutex_unlock(&video->video_lock);
+
 	return v4l2_fh_open(file);
 }
 
@@ -1260,34 +1317,129 @@ static int aspeed_video_release(struct file *file)
 	int rc;
 	struct aspeed_video *video = video_drvdata(file);
 
-	rc = v4l2_fh_release(file);
+	rc = vb2_fop_release(file);
+
+	mutex_lock(&video->video_lock);
 
 	if (atomic_dec_return(&video->clients) == 0)
 		aspeed_video_stop(video);
 
+	mutex_unlock(&video->video_lock);
+
 	return rc;
 }
 
 static const struct v4l2_file_operations aspeed_video_v4l2_fops = {
 	.owner = THIS_MODULE,
-	.read = aspeed_video_file_read,
-	.poll = v4l2_ctrl_poll,
+	.read = vb2_fop_read,
+	.poll = vb2_fop_poll,
 	.unlocked_ioctl = video_ioctl2,
+	.mmap = vb2_fop_mmap,
 	.open = aspeed_video_open,
 	.release = aspeed_video_release,
 };
 
-static void aspeed_video_device_release(struct video_device *vdev)
+static int aspeed_video_queue_setup(struct vb2_queue *q,
+				    unsigned int *num_buffers,
+				    unsigned int *num_planes,
+				    unsigned int sizes[],
+				    struct device *alloc_devs[])
 {
+	struct aspeed_video *video = vb2_get_drv_priv(q);
+
+	if (*num_planes) {
+		if (sizes[0] < video->max_compressed_size)
+			return -EINVAL;
+
+		return 0;
+	}
+
+	*num_planes = 1;
+	sizes[0] = video->max_compressed_size;
+
+	return 0;
 }
 
-static int aspeed_video_setup_video(struct aspeed_video *video)
+static int aspeed_video_buf_prepare(struct vb2_buffer *vb)
+{
+	struct aspeed_video *video = vb2_get_drv_priv(vb->vb2_queue);
+
+	if (vb2_plane_size(vb, 0) < video->max_compressed_size)
+		return -EINVAL;
+
+	return 0;
+}
+
+static int aspeed_video_start_streaming(struct vb2_queue *q,
+					unsigned int count)
+{
+	int rc;
+	struct aspeed_video *video = vb2_get_drv_priv(q);
+
+	rc = aspeed_video_start_frame(video);
+	if (rc) {
+		aspeed_video_bufs_done(video, VB2_BUF_STATE_QUEUED);
+		return rc;
+	}
+
+	video->sequence = 0;
+	set_bit(VIDEO_STREAMING, &video->flags);
+	return 0;
+}
+
+static void aspeed_video_stop_streaming(struct vb2_queue *q)
 {
 	int rc;
-	u64 mask = ~(BIT(V4L2_JPEG_CHROMA_SUBSAMPLING_444) |
-		     BIT(V4L2_JPEG_CHROMA_SUBSAMPLING_420));
+	struct aspeed_video *video = vb2_get_drv_priv(q);
+
+	clear_bit(VIDEO_STREAMING, &video->flags);
+
+	rc = wait_event_timeout(video->wait,
+				!test_bit(VIDEO_FRAME_INPRG, &video->flags),
+				STOP_TIMEOUT);
+	if (!rc) {
+		dev_err(video->dev, "Timed out when stopping streaming\n");
+		aspeed_video_stop(video);
+	}
+
+	aspeed_video_bufs_done(video, VB2_BUF_STATE_ERROR);
+}
+
+static void aspeed_video_buf_queue(struct vb2_buffer *vb)
+{
+	struct aspeed_video *video = vb2_get_drv_priv(vb->vb2_queue);
+	struct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);
+	struct aspeed_video_buffer *avb = to_aspeed_video_buffer(vbuf);
+	unsigned long flags;
+
+	spin_lock_irqsave(&video->lock, flags);
+	list_add_tail(&avb->link, &video->buffers);
+	spin_unlock_irqrestore(&video->lock, flags);
+}
+
+static const struct vb2_ops aspeed_video_vb2_ops = {
+	.queue_setup = aspeed_video_queue_setup,
+	.wait_prepare = vb2_ops_wait_prepare,
+	.wait_finish = vb2_ops_wait_finish,
+	.buf_prepare = aspeed_video_buf_prepare,
+	.start_streaming = aspeed_video_start_streaming,
+	.stop_streaming = aspeed_video_stop_streaming,
+	.buf_queue =  aspeed_video_buf_queue,
+};
+
+static int aspeed_video_setup_video(struct aspeed_video *video)
+{
+	const u64 mask = ~(BIT(V4L2_JPEG_CHROMA_SUBSAMPLING_444) |
+			   BIT(V4L2_JPEG_CHROMA_SUBSAMPLING_420));
 	struct v4l2_device *v4l2_dev = &video->v4l2_dev;
+	struct vb2_queue *vbq = &video->queue;
 	struct video_device *vdev = &video->vdev;
+	int rc;
+
+	video->pix_fmt.pixelformat = V4L2_PIX_FMT_JPEG;
+	video->pix_fmt.field = V4L2_FIELD_NONE;
+	video->pix_fmt.colorspace = V4L2_COLORSPACE_SRGB;
+	video->pix_fmt.quantization = V4L2_QUANTIZATION_FULL_RANGE;
 
 	rc = v4l2_device_register(video->dev, v4l2_dev);
 	if (rc) {
@@ -1295,50 +1447,69 @@ static int aspeed_video_setup_video(struct aspeed_video *video)
 		return rc;
 	}
 
+	v4l2_ctrl_handler_init(&video->ctrl_handler, 2);
+	v4l2_ctrl_new_std(&video->ctrl_handler, &aspeed_video_ctrl_ops,
+			  V4L2_CID_JPEG_COMPRESSION_QUALITY, 0,
+			  ASPEED_VIDEO_JPEG_NUM_QUALITIES - 1, 1, 0);
+	v4l2_ctrl_new_std_menu(&video->ctrl_handler, &aspeed_video_ctrl_ops,
+			       V4L2_CID_JPEG_CHROMA_SUBSAMPLING,
+			       V4L2_JPEG_CHROMA_SUBSAMPLING_420, mask,
+			       V4L2_JPEG_CHROMA_SUBSAMPLING_444);
+
+	if (video->ctrl_handler.error) {
+		v4l2_ctrl_handler_free(&video->ctrl_handler);
+		v4l2_device_unregister(v4l2_dev);
+
+		dev_err(video->dev, "Failed to init controls: %d\n",
+			video->ctrl_handler.error);
+		return rc;
+	}
+
+	v4l2_dev->ctrl_handler = &video->ctrl_handler;
+
+	vbq->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+	vbq->io_modes = VB2_MMAP | VB2_READ | VB2_DMABUF;
+	vbq->dev = v4l2_dev->dev;
+	vbq->lock = &video->video_lock;
+	vbq->ops = &aspeed_video_vb2_ops;
+	vbq->mem_ops = &vb2_dma_contig_memops;
+	vbq->drv_priv = video;
+	vbq->buf_struct_size = sizeof(struct aspeed_video_buffer);
+	vbq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;
+	vbq->min_buffers_needed = 3;
+
+	rc = vb2_queue_init(vbq);
+	if (rc) {
+		v4l2_ctrl_handler_free(&video->ctrl_handler);
+		v4l2_device_unregister(v4l2_dev);
+
+		dev_err(video->dev, "Failed to init vb2 queue\n");
+		return rc;
+	}
+
+	vdev->queue = vbq;
 	vdev->fops = &aspeed_video_v4l2_fops;
-	vdev->device_caps = V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_READWRITE;
+	vdev->device_caps = V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_READWRITE |
+		V4L2_CAP_STREAMING;
 	vdev->v4l2_dev = v4l2_dev;
-	strncpy(vdev->name, DEVICE_NAME, sizeof(vdev->name));
+	strscpy(vdev->name, DEVICE_NAME, sizeof(vdev->name));
 	vdev->vfl_type = VFL_TYPE_GRABBER;
 	vdev->vfl_dir = VFL_DIR_RX;
-	vdev->release = aspeed_video_device_release;
+	vdev->release = video_device_release_empty;
 	vdev->ioctl_ops = &aspeed_video_ioctl_ops;
 	vdev->lock = &video->video_lock;
 
 	video_set_drvdata(vdev, video);
 	rc = video_register_device(vdev, VFL_TYPE_GRABBER, 0);
 	if (rc) {
+		vb2_queue_release(vbq);
+		v4l2_ctrl_handler_free(&video->ctrl_handler);
 		v4l2_device_unregister(v4l2_dev);
+
 		dev_err(video->dev, "Failed to register video device\n");
 		return rc;
 	}
 
-	video->v4l2_fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-	video->v4l2_fmt.fmt.pix.pixelformat = V4L2_PIX_FMT_JPEG;
-	video->v4l2_fmt.fmt.pix.field = V4L2_FIELD_NONE;
-	video->v4l2_fmt.fmt.pix.colorspace = V4L2_COLORSPACE_JPEG;
-
-	/* Don't fail the probe if controls init fails */
-	v4l2_ctrl_handler_init(&video->v4l2_ctrl, 2);
-
-	v4l2_ctrl_new_std(&video->v4l2_ctrl, &aspeed_video_ctrl_ops,
-			  V4L2_CID_JPEG_COMPRESSION_QUALITY, 0,
-			  ASPEED_VIDEO_JPEG_NUM_QUALITIES - 1, 1, 0);
-
-	v4l2_ctrl_new_std_menu(&video->v4l2_ctrl, &aspeed_video_ctrl_ops,
-			       V4L2_CID_JPEG_CHROMA_SUBSAMPLING,
-			       V4L2_JPEG_CHROMA_SUBSAMPLING_420, mask,
-			       V4L2_JPEG_CHROMA_SUBSAMPLING_444);
-
-	if (video->v4l2_ctrl.error) {
-		dev_info(video->dev, "Failed to init controls: %d\n",
-			 video->v4l2_ctrl.error);
-		v4l2_ctrl_handler_free(&video->v4l2_ctrl);
-	} else {
-		v4l2_dev->ctrl_handler = &video->v4l2_ctrl;
-		vdev->ctrl_handler = &video->v4l2_ctrl;
-	}
-
 	return 0;
 }
 
@@ -1392,6 +1563,15 @@ static int aspeed_video_init(struct aspeed_video *video)
 		return rc;
 	}
 
+	if (!aspeed_video_alloc_buf(video, &video->jpeg,
+				    VE_JPEG_HEADER_SIZE)) {
+		dev_err(dev, "Failed to allocate DMA for JPEG header\n");
+		of_reserved_mem_device_release(dev);
+		return rc;
+	}
+
+	aspeed_video_init_jpeg_table(video->jpeg.virt, video->yuv420);
+
 	return 0;
 }
 
@@ -1409,6 +1589,7 @@ static int aspeed_video_probe(struct platform_device *pdev)
 	mutex_init(&video->video_lock);
 	init_waitqueue_head(&video->wait);
 	INIT_DELAYED_WORK(&video->res_work, aspeed_video_resolution_work);
+	INIT_LIST_HEAD(&video->buffers);
 
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 
@@ -1434,13 +1615,17 @@ static int aspeed_video_remove(struct platform_device *pdev)
 	struct v4l2_device *v4l2_dev = dev_get_drvdata(dev);
 	struct aspeed_video *video = to_aspeed_video(v4l2_dev);
 
-	if (video->vdev.ctrl_handler)
-		v4l2_ctrl_handler_free(&video->v4l2_ctrl);
-
 	video_unregister_device(&video->vdev);
 
+	vb2_queue_release(&video->queue);
+
+	v4l2_ctrl_handler_free(&video->ctrl_handler);
+
 	v4l2_device_unregister(v4l2_dev);
 
+	dma_free_coherent(video->dev, VE_JPEG_HEADER_SIZE, video->jpeg.virt,
+			  video->jpeg.dma);
+
 	of_reserved_mem_device_release(dev);
 
 	return 0;
